#include <U8g2lib.h>
#include <ELECHOUSE_CC1101_SRC_DRV.h>
#include <RCSwitch.h>

//bluetooth
#include <NimBLEDevice.h>
NimBLEAdvertising *pAdvertising;
//BLE END

//Wifi
#include <WiFi.h>
#include <esp_wifi.h>

#ifdef U8X8_HAVE_HW_I2C
#include <Wire.h>
#endif

#define RX_PIN 4         // Pino de recepção
#define TX_PIN 2         // Pino de transmissão
#define BUTTON_PIN 14    // Pino do botão
#define BUTTON_PIN_DIR 27    // Pino do botão
#define BUTTON_PIN_ESQ 12    // Pino do botão
#define BUTTON_PIN_UP 26    // Pino do botão
#define FREQUENCY_SWITCH_PIN 13 // Pino do interruptor para mudar a frequência
#define SCREEN_WIDTH 128 // Largura da tela OLED
#define SCREEN_HEIGHT 64 // Altura da tela OLED

U8G2_SH1106_128X64_NONAME_F_HW_I2C u8g2(U8G2_R0, /* reset=*/ U8X8_PIN_NONE);

#define scary_width 128
#define scary_height 64
unsigned const char scary_bits[] = {
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x8F,
  0xE0, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0xEF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0x03, 0xE0, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0xE0, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0xC0, 0x07, 0x00, 0xFE,
  0xFF, 0x0F, 0xE0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03,
  0x00, 0x03, 0x00, 0xFF, 0xFF, 0x07, 0xE0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0x03, 0x00, 0x06, 0x00, 0xFF, 0xFF, 0x03, 0xE0, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x87, 0x00, 0x06, 0x00, 0xFF,
  0xFF, 0x03, 0xE0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x87,
  0x05, 0x06, 0x10, 0xFF, 0xFF, 0x01, 0xE1, 0xFF, 0xFB, 0xFF, 0xFF, 0xFF,
  0xCF, 0x9F, 0xFF, 0x87, 0x0D, 0x06, 0xBE, 0xFF, 0xFF, 0x81, 0xE3, 0xDF,
  0xF9, 0xFF, 0x80, 0xFB, 0xE3, 0xC7, 0xFF, 0x87, 0x0D, 0x06, 0xBE, 0xFF,
  0xFF, 0xC1, 0xE7, 0x07, 0xE8, 0xF3, 0x80, 0xF1, 0xE0, 0xE1, 0xFF, 0x87,
  0x0F, 0x06, 0xFF, 0xFF, 0xFF, 0xC0, 0xFF, 0x03, 0xC8, 0xE0, 0x03, 0x60,
  0x60, 0xE0, 0xFF, 0x83, 0x0F, 0x06, 0xFF, 0xFF, 0xFF, 0xC1, 0xFF, 0x00,
  0x0C, 0x80, 0x03, 0xC0, 0xE0, 0xE0, 0xFF, 0x83, 0x0F, 0x07, 0xFF, 0xFF,
  0xFF, 0x01, 0xFE, 0x00, 0x0C, 0x00, 0x03, 0xC0, 0xE0, 0xE1, 0xFF, 0x87,
  0x07, 0x07, 0xF7, 0xFF, 0xFF, 0x01, 0xFC, 0x20, 0x0C, 0x00, 0x83, 0xC0,
  0xE0, 0xE1, 0xFF, 0x83, 0x03, 0x07, 0xF3, 0xFF, 0xFF, 0x03, 0xF8, 0x30,
  0x0C, 0x06, 0x83, 0xC1, 0xE0, 0xC1, 0xFF, 0x83, 0x00, 0x07, 0xF3, 0xFF,
  0xFF, 0x03, 0x70, 0xB0, 0x0C, 0x07, 0x83, 0xC1, 0xE0, 0xC1, 0xFF, 0x87,
  0x80, 0x07, 0xF0, 0xFF, 0xFF, 0x03, 0x60, 0xF0, 0x8C, 0x03, 0x83, 0xC1,
  0xE0, 0xE1, 0xFF, 0x07, 0xC0, 0x07, 0xF0, 0xFF, 0xFF, 0xEF, 0x60, 0xF8,
  0xE6, 0x00, 0x83, 0xE1, 0xE0, 0xE1, 0xFF, 0x07, 0xC0, 0x07, 0xF0, 0xFF,
  0xFF, 0xEF, 0x61, 0xF8, 0x3E, 0x00, 0x83, 0xE3, 0xE0, 0xE1, 0xFF, 0x03,
  0x00, 0x07, 0xF0, 0xFF, 0xFF, 0xFF, 0x21, 0xF8, 0x1E, 0x00, 0x83, 0xE3,
  0xE1, 0xE1, 0xFF, 0x03, 0x00, 0x07, 0xF3, 0xFF, 0xFF, 0xFF, 0x01, 0xF8,
  0x0F, 0x0C, 0x83, 0xFB, 0xE0, 0xE1, 0xFF, 0x83, 0x03, 0x07, 0xF3, 0xFF,
  0xFF, 0xFF, 0x01, 0xF8, 0x0F, 0x0E, 0x83, 0xFF, 0xF0, 0xE1, 0xFF, 0x83,
  0x07, 0x0F, 0xF7, 0xFF, 0xFF, 0xF7, 0x01, 0xF8, 0x05, 0x0F, 0x83, 0xFB,
  0xE0, 0xE1, 0xFF, 0x83, 0x07, 0x0F, 0xFF, 0xFF, 0xFF, 0x63, 0x00, 0xF8,
  0x85, 0x0F, 0xC3, 0xFF, 0x60, 0xE0, 0xFF, 0x83, 0x07, 0x0F, 0xFF, 0xFF,
  0xFF, 0x43, 0x60, 0xF0, 0x84, 0x0F, 0xC3, 0xFF, 0x00, 0xE0, 0xFF, 0x07,
  0x07, 0x0F, 0xFF, 0xFF, 0xFF, 0x43, 0x60, 0xF0, 0x0C, 0x0B, 0xC3, 0xFF,
  0x00, 0xE0, 0xFF, 0x03, 0x87, 0x0F, 0xFF, 0xFF, 0xFF, 0x03, 0xF0, 0x00,
  0x0C, 0x03, 0xC3, 0xFF, 0x03, 0xE0, 0xFF, 0x03, 0x87, 0x0F, 0xFF, 0xFF,
  0xFF, 0x03, 0xF0, 0x00, 0x0C, 0x00, 0xE3, 0xFF, 0x0F, 0xE0, 0xFF, 0x03,
  0x87, 0x8F, 0xFF, 0xFF, 0xFF, 0x03, 0xF0, 0x01, 0x0C, 0x00, 0xE2, 0xFF,
  0x0E, 0xE0, 0xFF, 0x03, 0x87, 0x8F, 0xFF, 0xFF, 0xFF, 0x03, 0xF4, 0x07,
  0x1C, 0x00, 0xEA, 0xFF, 0xDE, 0xE0, 0xFF, 0x01, 0x87, 0x0F, 0xFF, 0xFF,
  0xFF, 0x0F, 0xF6, 0x0F, 0x1C, 0x2E, 0xF8, 0xFF, 0xDC, 0xE0, 0xFF, 0x00,
  0x86, 0x8F, 0xFF, 0xFF, 0xFF, 0x1F, 0xFF, 0x6F, 0xBC, 0xAF, 0xFB, 0xFF,
  0xFC, 0xE0, 0xFF, 0xFF, 0xC7, 0x8F, 0xFF, 0xFF, 0xFF, 0x9F, 0xFF, 0x7F,
  0xBC, 0xFF, 0xFB, 0xFF, 0x78, 0xF0, 0xFF, 0xFF, 0xC7, 0xDF, 0xFF, 0xFF,
  0xFF, 0xDF, 0xFF, 0xFF, 0xFC, 0xFF, 0xFF, 0xFF, 0x30, 0xF8, 0xFF, 0xFF,
  0xCF, 0xDF, 0xFF, 0xFF, 0xFF, 0xDF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF,
  0x00, 0xFC, 0xFF, 0xFF, 0xEF, 0xDF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFE, 0xFF, 0xFF, 0xFF, 0x00, 0xFC, 0xFF, 0xFF, 0xEF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0x00, 0xFD, 0xFF, 0xFF,
  0xEF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0x04, 0xFF, 0xFF, 0xFF, 0xEF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0x0E, 0xFF, 0xFF, 0xFF, 0xEF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xBE, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xBF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE,
  0x7F, 0xFE, 0xFF, 0xFF, 0xFD, 0xFF, 0xFF, 0xFD, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFC, 0x7F, 0xFF, 0xFF, 0xFF, 0xFC, 0xFF, 0xFF, 0xFD,
  0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFD, 0x7F, 0xFF, 0xFF, 0x87,
  0xFC, 0xFF, 0xFF, 0xFC, 0x7F, 0x3F, 0xF8, 0x87, 0xFF, 0xFF, 0xFF, 0xFD,
  0x7F, 0xFF, 0xFF, 0xCF, 0x04, 0x04, 0x80, 0x0F, 0x60, 0xDF, 0xF1, 0x69,
  0xFF, 0xFF, 0xFF, 0xFD, 0x7F, 0xFF, 0xFF, 0xCF, 0x64, 0x26, 0xF9, 0x65,
  0x32, 0xFF, 0xF3, 0x59, 0xFE, 0xFF, 0xFF, 0xFD, 0x7F, 0xFE, 0xFF, 0xCF,
  0x64, 0x26, 0x01, 0x64, 0x32, 0x1F, 0xF2, 0x53, 0xFE, 0xFF, 0xFF, 0xFD,
  0x7F, 0xFF, 0xFF, 0xCF, 0x64, 0xA7, 0xBD, 0x64, 0x12, 0x9F, 0xF9, 0x53,
  0xFE, 0xFF, 0xFF, 0xFD, 0x7F, 0xFF, 0xFF, 0xCF, 0xA4, 0xA7, 0x9F, 0x64,
  0x12, 0x9F, 0xFF, 0x53, 0xFE, 0xFF, 0xFF, 0xFD, 0x7F, 0xFF, 0xFF, 0xCF,
  0xC4, 0xE6, 0x9B, 0x64, 0x22, 0x9F, 0xF6, 0x53, 0xFE, 0xFF, 0xFF, 0xFD,
  0x7F, 0xFE, 0xFF, 0xC7, 0x64, 0xE6, 0x99, 0x64, 0x22, 0x9F, 0xF2, 0x53,
  0xFE, 0xFF, 0xFF, 0xFD, 0x7F, 0xFF, 0xFF, 0x8F, 0x66, 0xE6, 0xD9, 0x64,
  0x32, 0x9F, 0xF2, 0x71, 0xFE, 0xFF, 0xFF, 0xFD, 0x7F, 0xFF, 0xFF, 0x1F,
  0x02, 0xE3, 0x00, 0x00, 0x13, 0x9F, 0x32, 0x63, 0xFE, 0xFF, 0xFF, 0xFD,
  0x7F, 0xFF, 0xFF, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFB, 0x9F, 0x33, 0x87,
  0xFF, 0xFF, 0xFF, 0xFD, 0x7F, 0xFF, 0xFF, 0xBF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFB, 0x0F, 0xA0, 0xDF, 0xFF, 0xFF, 0xFF, 0xFD, 0x7F, 0xFC, 0xFF, 0xFB,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFB, 0xFF, 0xFF, 0xFB, 0x7F, 0xEF, 0xF7, 0xFC,
  0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF,
};


RCSwitch mySwitch = RCSwitch();

unsigned long receivedValue = 0;
int receivedBitLength = 0;
int receivedProtocol = 0;
const int rssi_threshold = -75;
float mhz;

static const uint32_t subghz_frequency_list[] = {
  300000000, 303875000, 304250000, 310000000, 315000000, 318000000,
  390000000, 418000000, 433075000, 433420000, 433920000, 434420000, 434775000, 438900000,
  868350000, 915000000, 925000000
};

#define WAVEFORM_SAMPLES 128
int waveform[WAVEFORM_SAMPLES] = {0};
int waveformIndex = 0;

// Estrutura para itens do menu
struct menu_entry_type {
  const uint8_t *font;
  uint16_t icon;
  const char *name;
  const menu_entry_type *submenu;
};

// Estrutura para o estado do menu
struct menu_state {
  uint8_t position;    // posição, índice do array
  const menu_entry_type *menu; // menu atual
};

#define ICON_WIDTH 32
#define ICON_HEIGHT 32
#define ICON_GAP 4
#define ICON_BGAP 16
#define ICON_Y 32 + ICON_GAP

// Itens do submenu para "Radio Freq"
const menu_entry_type radio_freq_submenu[] = {
  { u8g2_font_open_iconic_all_4x_t, 211, "Replay", NULL },
  { u8g2_font_open_iconic_all_4x_t, 238, "Raw", NULL },
  { u8g2_font_open_iconic_all_4x_t, 165, "Analyser", NULL },
  { u8g2_font_open_iconic_all_4x_t, 240, "Random", NULL },
  { NULL, 0, NULL, NULL }
};

// Itens do submenu para "Wifi"
const menu_entry_type wifi_submenu[] = {
  { u8g2_font_open_iconic_all_4x_t, 104, "Evil portal", NULL },
  { u8g2_font_open_iconic_all_4x_t, 153, "Deauther", NULL },
  { u8g2_font_open_iconic_all_4x_t, 175, "Internet Connect", NULL },
  { NULL, 0, NULL, NULL }
};

// Itens do submenu para "Bluetooth"
const menu_entry_type bluetooth_submenu[] = {
  { u8g2_font_open_iconic_all_4x_t, 230, "BLE Spam", NULL },
  { NULL, 0, NULL, NULL }
};

// Entradas do menu principal
const menu_entry_type menu_entry_list[] = {
  { u8g2_font_open_iconic_all_4x_t, 84, "Radio Freq", radio_freq_submenu },
  { u8g2_font_open_iconic_all_4x_t, 247, "Wifi", wifi_submenu },
  { u8g2_font_open_iconic_all_4x_t, 94, "Bluetooth", bluetooth_submenu },
  { u8g2_font_open_iconic_all_4x_t, 129, "Configuration", NULL },
  { NULL, 0, NULL, NULL }
};

bool in_menu = true; // Variável para rastrear se estamos no menu

void draw_menu(struct menu_state *state) {
  int16_t x = (u8g2.getDisplayWidth() - ICON_WIDTH) / 2; // Centraliza o ícone horizontalmente
  uint8_t i = state->position;

  u8g2.setFlipMode(3); // Rotaciona a tela
  u8g2.clearBuffer();

  // Desenha o ícone atual
  u8g2.setFont(state->menu[i].font);
  u8g2.drawGlyph(x, ICON_Y, state->menu[i].icon);

  // Desenha o contorno ao redor do ícone atual
  u8g2.drawFrame(x - 1, ICON_Y - ICON_HEIGHT - 1, ICON_WIDTH + 2, ICON_HEIGHT + 2);
  u8g2.drawFrame(x - 2, ICON_Y - ICON_HEIGHT - 2, ICON_WIDTH + 4, ICON_HEIGHT + 4);
  u8g2.drawFrame(x - 3, ICON_Y - ICON_HEIGHT - 3, ICON_WIDTH + 6, ICON_HEIGHT + 6);

  // Desenha o nome da entrada de menu atual
  u8g2.setFont(u8g2_font_6x10_tf);
  u8g2.setCursor((u8g2.getDisplayWidth() - u8g2.getStrWidth(state->menu[i].name)) / 2, u8g2.getDisplayHeight() - 5);
  u8g2.print(state->menu[i].name);

  u8g2.sendBuffer();
}

void to_right(struct menu_state *state) {
  if (state->menu[state->position + 1].font != NULL) {
    state->position++;
  }
}

void to_left(struct menu_state *state) {
  if (state->position > 0) {
    state->position--;
  }
}

struct menu_state current_state = { 0, menu_entry_list };

void setup() { // ==============================SETUP=============================================
  Serial.begin(115200);


  pinMode(BUTTON_PIN, INPUT_PULLUP);
  pinMode(FREQUENCY_SWITCH_PIN, INPUT_PULLUP);
  pinMode(BUTTON_PIN_UP, INPUT_PULLUP);
  pinMode(BUTTON_PIN_DIR, INPUT_PULLUP);
  pinMode(BUTTON_PIN_ESQ, INPUT_PULLUP);

  u8g2.begin();
  u8g2.enableUTF8Print();  // Permite imprimir caracteres UTF-8
  ELECHOUSE_cc1101.Init();


  u8g2.begin();
  u8g2.clearBuffer();
  u8g2.setFlipMode(3); //rotaciona tela
  u8g2.setFont(u8g2_font_6x10_tf);

  u8g2.firstPage();
  do {
    u8g2.drawXBMP(0, 0, scary_width, scary_height, scary_bits);
  } while (u8g2.nextPage());
  while (digitalRead(BUTTON_PIN_DIR) != LOW && digitalRead(BUTTON_PIN) != LOW && digitalRead(BUTTON_PIN_ESQ) != LOW && digitalRead(BUTTON_PIN_UP) != LOW) {
    //Aguarda pressionar algo pra sair da tela inicial
  }

  if (digitalRead(FREQUENCY_SWITCH_PIN) == LOW) {
    ELECHOUSE_cc1101.setMHZ(315);
    mhz = 315.00;
  } else {
    ELECHOUSE_cc1101.setMHZ(433.92);
    mhz = 433.00;
  }

  ELECHOUSE_cc1101.SetRx();

  mySwitch.enableReceive(RX_PIN);
  mySwitch.enableTransmit(TX_PIN);

  Blesetup();
}




void loop() {

  int8_t event = 0;

  if (digitalRead(BUTTON_PIN_DIR) == LOW) {
    event = 1; // Representa U8X8_MSG_GPIO_MENU_NEXT
  } else if (digitalRead(BUTTON_PIN_ESQ) == LOW) {
    event = 2; // Representa U8X8_MSG_GPIO_MENU_PREV
  } else if (digitalRead(BUTTON_PIN) == LOW) {
    event = 3; // Representa U8X8_MSG_GPIO_MENU_SELECT
  } else if (digitalRead(BUTTON_PIN_UP) == LOW) {
    event = 4; // Representa a função de voltar para o menu principal
  }

  if (in_menu) {
    if (event == 1) {
      to_right(&current_state);
    }
    if (event == 2) {
      to_left(&current_state);
    }
    if (event == 3) {
      if (current_state.menu[current_state.position].submenu != NULL) {
        current_state.menu = current_state.menu[current_state.position].submenu;
        current_state.position = 0;
      }   else {
        if (strcmp(current_state.menu[current_state.position].name, "Replay") == 0) { //Funçao Replay
          Detect();

        } //________ End Replay

        if (strcmp(current_state.menu[current_state.position].name, "Raw") == 0) { //Funçao RAW
          while (digitalRead(BUTTON_PIN_UP) != LOW) {
            Raw();
          }
        }
        //________ End RAW
        if (strcmp(current_state.menu[current_state.position].name, "Analyser") == 0) { //Funçao Analyser
          while (digitalRead(BUTTON_PIN_UP) != LOW) {
            Analyser();     
          }
        } //________ End ANALYSER

        if (strcmp(current_state.menu[current_state.position].name, "Random") == 0) { //Funçao Random
          while (digitalRead(BUTTON_PIN_UP) != LOW) {
            if (digitalRead(BUTTON_PIN) == LOW) {
              SendRandom();
            }
          }
        } //________ End RANDOM
        if (strcmp(current_state.menu[current_state.position].name, "Deauther") == 0) { //Funçao Deauther
        while (digitalRead(BUTTON_PIN_UP) != LOW) {
            Deauther();
        }
        }//________ End Deauther
        if (strcmp(current_state.menu[current_state.position].name, "Evil portal") == 0) { //Funçao EVIL PORTAL
        u8g2.clearBuffer();
        u8g2.setCursor(0, 10);
        u8g2.print("In progress...");
        } //________ End Evil
        if (strcmp(current_state.menu[current_state.position].name, "BLE Spam") == 0) { //Funçao Spam
          while (digitalRead(BUTTON_PIN_UP) != LOW) {                      
            Bleloop();
          }
        } //________ End Spam

      }

    }

    if (event == 4 && current_state.menu != menu_entry_list) {
      // Se o botão UP for pressionado e estiver em um submenu, volte para o menu principal
      current_state.menu = menu_entry_list;
      current_state.position = 0;
      in_menu = true; // Garante que o menu seja desenhado
      delay(100);
    }

    if (in_menu) {
      draw_menu(&current_state);
    }

    delay(100); // Atraso para evitar o efeito de bounce
  }
}
